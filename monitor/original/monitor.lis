
Source file: MONITOR.X68
Assembled on: 16-08-15 at: 15:35:19
          by: X68K PC-2.2 Copyright (c) University of Teesside 1989,96
Defaults: ORG $0/FORMAT/OPT A,BRL,CEX,CL,FRL,MC,MD,NOMEX,NOPCO

    1                        *        TSBUG2 - 68000 monitor - version of 23 July 1986 
    2                        *                                   Symbol equates 
    3           00000008     BS:       EQU       $08                   ;Back_space 
    4           0000000D     CR:       EQU       $0D                   ;Carriage_return 
    5           0000000A     LF:       EQU       $0A                   ;Line_feed 
    6           00000020     SPACE:    EQU       $20                   ;Space 
    7           57000000     WAIT:     EQU       'W'                   ;Wait character (to suspend output) 
    8           0000001B     ESC:      EQU       $1B                   ;ASCII escape character (used by TM) 
    9           00000001     CTRL_A:   EQU       $01                   ;Control_A forces return to monitor 
   10                        *                                   Device addresses 
   11           00000800     STACK:    EQU       $00000800             ;Stack_pointer 
   12           00010040     ACIA_1:   EQU       $00010040             ;Console ACIA control 
   13           00010041     ACIA_2:   EQU       ACIA_1+1              ;Auxilary ACIA control 
   14           00000008     X_BASE:   EQU       $08                   ;Start of exception vector table 
   15           00004E4E     TRAP_14:  EQU       $4E4E                 ;Code for TRAP #14 
   16           00000040     MAXCHR:   EQU       64                    ;Length of input line buffer  
   17                        * 
   18           00000C00     DATA:     EQU       $00000C00             ;Data origin 
   19  00000000 00000040     LNBUFF:   DS.B      MAXCHR                ;Input line buffer
   20           0000003F     BUFFEND:  EQU       LNBUFF+MAXCHR-1       ;End of line buffer 
   21  00000040 00000004     BUFFPT:   DS.L      1                     ;Pointer to line buffer 
   22  00000044 00000004     PARAMTR:  DS.L      1                     ;Last parameter from line buffer 
   23  00000048 00000001     ECHO:     DS.B      1                     ;When clear this enable input echo 
   24  00000049 00000001     U_CASE:   DS.B      1                     ;Flag for upper case conversion 
   25  0000004A 00000004     UTAB:     DS.L      1                     ;Pointer to user command table 
   26  0000004E 00000004     CN_IVEC:  DS.L      1                     ;Pointer to console input DCB 
   27  00000052 00000004     CN_OVEC:  DS.L      1                     ;Pointer to console output DCB 
   28  00000056 0000004A     TSK_T:    DS.W      37                    ;Frame for D0-D7, A0-A6, USP, SSP, SW, PC 
   29  000000A0 00000030     BP_TAB:   DS.W      24                    ;Breakpoint table 
   30  000000D0 00000200     FIRST:    DS.B      512                   ;DCB area 
   31  000002D0 00000100     BUFFER:   DS.B      256                   ;256 bytes for I/O buffer 
   32                        * 
   33                        ************************************************************************* 
   34                        * 
   35                        *  This is the main program which assembles a command in the line 
   36                        *  buffer, removes leading/embedded spaces and interprets it by matching 
   37                        *  it with a command in the user table or the built-in table COMTAB 
   38                        *  All variables are specified with respect to A6 
   39                        * 
   40  00008000                        ORG       $00008000             ;Monitor origin 
   41  00008000 00000800               DC.L      STACK                 ;Reset stack pointer 
   42  00008004 00008008               DC.L      RESET                 ;Reset vector 
   43           00008008     RESET:    EQU       *                     ;Cold entry point for monitor 
   44  00008008 4DF80C00               LEA.L     DATA,A6               ;A6 points to data area 
   45  0000800C 42AE004A               CLR.L     UTAB(A6)              ;Reset pointer to user extension table 
   46  00008010 422E0048               CLR.B     ECHO(A6)              ;Set automatic character echo 
   47  00008014 422E0049               CLR.B     U_CASE(A6)            ;Clear case conversion flag (UC<-LC) 
   48  00008018 6136                   BSR.S     SETACIA               ;Setup ACIAs 
   49  0000801A 610005D8               BSR       X_SET                 ;Setup exception table 
   50  0000801E 6100044E               BSR       SET_DCB               ;Setup DCB table in RAM 
   51  00008022 49FA09D0               LEA.L     BANNER(PC),A4         ;Point to banner 
   52  00008026 6164                   BSR.S     HEADING               ;and print heading 
   53  00008028 207C0000C000           MOVE.L    #$0000C000,A0         ;A0 points to extension ROM 
   54  0000802E 2010                   MOVE.L    (A0),D0               ;Read first longword in extension ROM 
   55  00008030 0C80524F4D32           CMP.L     #'ROM2',D0            ;If extension begins with 'ROM2' then 
   56  00008036 6604                   BNE.S     NO_EXT                ;call the subroutine at EXT_ROM+8 
   57  00008038 4EA80008               JSR       8(A0)                 ;else continue 
   58  0000803C 4E71         NO_EXT:   NOP                             ;Two NOPs to allow for a future 
   59  0000803E 4E71                   NOP                             ;call to an initialization routine 
   60  00008040 4287         WARM:     CLR.L     D7                    ;Warm entry point - clear error flag 
   61  00008042 6128                   BSR.S     NEWLINE               ;Print a newline 
   62  00008044 614C                   BSR.S     GETLINE               ;Get a command line 
   63  00008046 61000080               BSR       TIDY                  ;Tidy up input buffer contents 
   64  0000804A 610000BE               BSR       EXECUTE               ;Interpret command 
   65  0000804E 60F0                   BRA       WARM                  ;Repeat indefinitely 
   66                        * 
   67                        ************************************************************************* 
   68                        * 
   69                        *  Some initialization and basic routines 
   70                        * 
   71           00008050     SETACIA:  EQU       *                     ;Setup ACIA parameters 
   72  00008050 41F900010040           LEA.L     ACIA_1,A0             ;A0 points to console ACIA 
   73  00008056 10BC0003               MOVE.B    #$03,(A0)             ;Reset ACIA1 
   74  0000805A 117C00030001           MOVE.B    #$03,1(A0)            ;Reset ACIA2 
   75  00008060 10BC0015               MOVE.B    #$15,(A0)             ;Set up ACIA1 constants (no IRQ, 
   76  00008064 117C00150001           MOVE.B    #$15,1(A0)            ;RTS* low, 8 bit, no parity, 1 stop) 
   77  0000806A 4E75                   RTS                             ;Return 
   78                        * 
   79           0000806C     NEWLINE:  EQU       *                     ;Move cursor to start of newline 
   80  0000806C 48E70008               MOVEM.L   A4,-(A7)              ;Save A4 
   81  00008070 49FA099C               LEA.L     CRLF(PC),A4           ;Point to CR/LF string 
   82  00008074 6106                   BSR.S     PSTRING               ;Print it 
   83  00008076 4CDF1000               MOVEM.L   (A7)+,A4              ;Restore A4 
   84  0000807A 4E75                   RTS                             ;Return 
   85                        * 
   86           0000807C     PSTRING:  EQU       *                     ;Display the string pointed at by A4 
   87  0000807C 2F00                   MOVE.L    D0,-(A7)              ;Save D0 
   88  0000807E 101C         PS1:      MOVE.B    (A4)+,D0              ;Get character to be printed 
   89  00008080 6706                   BEQ.S     PS2                   ;If null then return 
   90  00008082 6100050C               BSR       PUTCHAR               ;Else print it 
   91  00008086 60F6                   BRA       PS1                   ;Continue 
   92  00008088 201F         PS2:      MOVE.L    (A7)+,D0              ;Restore D0 and exit 
   93  0000808A 4E75                   RTS       
   94                        * 
   95  0000808C 61DE         HEADING:  BSR       NEWLINE               ;Same as PSTRING but with newline 
   96  0000808E 61EC                   BSR       PSTRING
   97  00008090 60DA                   BRA       NEWLINE
   98                        * 
   99                        ************************************************************************* 
  100                        * 
  101                        *  GETLINE  inputs a string of characters into a line buffer 
  102                        *           A3 points to next free entry in line buffer 
  103                        *           A2 points to end of buffer 
  104                        *           A1 points to start of buffer 
  105                        *           D0 holds character to be stored 
  106                        * 
  107  00008092 43EE0000     GETLINE:  LEA.L     LNBUFF(A6),A1         ;A1 points to start of line buffer 
  108  00008096 47D1                   LEA.L     (A1),A3               ;A3 points to start (initially) 
  109  00008098 45E90040               LEA.L     MAXCHR(A1),A2         ;A2 points to end of buffer 
  110  0000809C 610004C0     GETLN2:   BSR       GETCHAR               ;Get a character 
  111  000080A0 0C000001               CMP.B     #CTRL_A,D0            ;If control_A then reject this line 
  112  000080A4 671E                   BEQ.S     GETLN5                ;and get another line 
  113  000080A6 0C000008               CMP.B     #BS,D0                ;If back_space then move back pointer 
  114  000080AA 660A                   BNE.S     GETLN3                ;Else skip past wind-back routine 
  115  000080AC B7C9                   CMP.L     A1,A3                 ;First check for empty buffer 
  116  000080AE 67EC                   BEQ       GETLN2                ;If buffer empty then continue 
  117  000080B0 47EBFFFF               LEA       -1(A3),A3             ;Else decrement buffer pointer 
  118  000080B4 60E6                   BRA       GETLN2                ;and continue with next character 
  119  000080B6 16C0         GETLN3:   MOVE.B    D0,(A3)+              ;Store character and update pointer 
  120  000080B8 0C00000D               CMP.B     #CR,D0                ;Test for command terminator 
  121  000080BC 6602                   BNE.S     GETLN4                ;If not CR then skip past exit 
  122  000080BE 60AC                   BRA       NEWLINE               ;Else new line before next operation 
  123  000080C0 B7CA         GETLN4:   CMP.L     A2,A3                 ;Test for buffer overflow 
  124  000080C2 66D8                   BNE       GETLN2                ;If buffer not full then continue 
  125  000080C4 61A6         GETLN5:   BSR       NEWLINE               ;Else move to next line and 
  126  000080C6 60CA                   BRA       GETLINE               ;repeat this routine 
  127                        * 
  128                        ************************************************************************* 
  129                        * 
  130                        *  TIDY cleans up the line buffer by removing leading spaces and multiple 
  131                        *       spaces between parameters. At the end of TIDY, BUFFPT points to 
  132                        *       the first parameter following the command. 
  133                        *       A0 = pointer to line buffer. A1 = pointer to cleaned up buffer 
  134                        * 
  135  000080C8 41EE0000     TIDY:     LEA.L     LNBUFF(A6),A0         ;A0 points to line buffer 
  136  000080CC 43D0                   LEA.L     (A0),A1               ;A1 points to start of line buffer 
  137  000080CE 1018         TIDY1:    MOVE.B    (A0)+,D0              ;Read character from line buffer 
  138  000080D0 0C000020               CMP.B     #SPACE,D0             ;Repeat until the first non-space 
  139  000080D4 67F8                   BEQ       TIDY1                 ;character is found 
  140  000080D6 41E8FFFF               LEA.L     -1(A0),A0             ;Move pointer back to first char 
  141  000080DA 1018         TIDY2:    MOVE.B    (A0)+,D0              ;Move the string left to remove 
  142  000080DC 12C0                   MOVE.B    D0,(A1)+              ;any leading spaces 
  143  000080DE 0C000020               CMP.B     #SPACE,D0             ;Test for embedded space 
  144  000080E2 660A                   BNE.S     TIDY4                 ;If not space then test for EOL 
  145  000080E4 0C180020     TIDY3:    CMP.B     #SPACE,(A0)+          ;If space skip multiple embedded 
  146  000080E8 67FA                   BEQ       TIDY3                 ;spaces 
  147  000080EA 41E8FFFF               LEA.L     -1(A0),A0             ;Move back pointer 
  148  000080EE 0C00000D     TIDY4:    CMP.B     #CR,D0                ;Test for end_of_line (EOL) 
  149  000080F2 66E6                   BNE       TIDY2                 ;If not EOL then read next char 
  150  000080F4 41EE0000               LEA.L     LNBUFF(A6),A0         ;Restore buffer pointer 
  151  000080F8 0C10000D     TIDY5:    CMP.B     #CR,(A0)              ;Test for EOL 
  152  000080FC 6706                   BEQ.S     TIDY6                 ;If EOL then exit 
  153  000080FE 0C180020               CMP.B     #SPACE,(A0)+          ;Test for delimiter 
  154  00008102 66F4                   BNE       TIDY5                 ;Repeat until delimiter or EOL 
  155  00008104 2D480040     TIDY6:    MOVE.L    A0,BUFFPT(A6)         ;Update buffer pointer 
  156  00008108 4E75                   RTS       
  157                        * 
  158                        ************************************************************************* 
  159                        * 
  160                        *  EXECUTE matches the first command in the line buffer with the 
  161                        *  commands in a command table. An external table pointed at by 
  162                        *  UTAB is searched first and then the in-built table, COMTAB. 
  163                        * 
  164  0000810A 4AAE004A     EXECUTE:  TST.L     UTAB(A6)              ;Test pointer to user table 
  165  0000810E 670C                   BEQ.S     EXEC1                 ;If clear then try built-in table 
  166  00008110 266E004A               MOVE.L    UTAB(A6),A3           ;Else pick up pointer to user table 
  167  00008114 6120                   BSR.S     SEARCH                ;Look for command in user table 
  168  00008116 6404                   BCC.S     EXEC1                 ;If not found then try internal table 
  169  00008118 2653                   MOVE.L    (A3),A3               ;Else get absolute address of command 
  170  0000811A 4ED3                   JMP       (A3)                  ;from user table and execute it 
  171                        * 
  172  0000811C 47FA0A46     EXEC1:    LEA.L     COMTAB(PC),A3         ;Try built-in command table 
  173  00008120 6114                   BSR.S     SEARCH                ;Look for command in built-in table 
  174  00008122 6508                   BCS.S     EXEC2                 ;If found then execute command 
  175  00008124 49FA09CF               LEA.L     ERMES2(PC),A4         ;Else print "invalid command" 
  176  00008128 6000FF52               BRA.L     PSTRING               ;and return 
  177  0000812C 2653         EXEC2:    MOVE.L    (A3),A3               ;Get the relative command address 
  178  0000812E 49FA0A34               LEA.L     COMTAB(PC),A4         ;pointed at by A3 and add it to 
  179  00008132 D7CC                   ADD.L     A4,A3                 ;the PC to generate the actual 
  180  00008134 4ED3                   JMP       (A3)                  ;command address. Then execute it. 
  181                        * 
  182           00008136     SEARCH:   EQU       *                     ;Match the command in the line buffer 
  183  00008136 4280                   CLR.L     D0                    ;with command table pointed at by A3 
  184  00008138 1013                   MOVE.B    (A3),D0               ;Get the first character in the 
  185  0000813A 6734                   BEQ.S     SRCH7                 ;current entry. If zero then exit 
  186  0000813C 49F30006               LEA.L     6(A3,D0.W),A4         ;Else calculate address of next entry 
  187  00008140 122B0001               MOVE.B    1(A3),D1              ;Get number of characters to match 
  188  00008144 4BEE0000               LEA.L     LNBUFF(A6),A5         ;A5 points to command in line buffer 
  189  00008148 142B0002               MOVE.B    2(A3),D2              ;Get first character in this entry 
  190  0000814C B41D                   CMP.B     (A5)+,D2              ;from the table and match with buffer 
  191  0000814E 6704                   BEQ.S     SRCH3                 ;If match then try rest of string 
  192  00008150 264C         SRCH2:    MOVE.L    A4,A3                 ;Else get address of next entry 
  193  00008152 60E2                   BRA       SEARCH                ;and try the next entry in the table 
  194  00008154 5301         SRCH3:    SUB.B     #1,D1                 ;One less character to match 
  195  00008156 670E                   BEQ.S     SRCH6                 ;If match counter zero then all done 
  196  00008158 47EB0003               LEA.L     3(A3),A3              ;Else point to next character in table 
  197  0000815C 141B         SRCH4:    MOVE.B    (A3)+,D2              ;Now match a pair of characters 
  198  0000815E B41D                   CMP.B     (A5)+,D2
  199  00008160 66EE                   BNE       SRCH2                 ;If no match then try next entry 
  200  00008162 5301                   SUB.B     #1,D1                 ;Else decrement match counter and 
  201  00008164 66F6                   BNE       SRCH4                 ;repeat until no chars left to match 
  202  00008166 47ECFFFC     SRCH6:    LEA.L     -4(A4),A3             ;Calculate address of command entry 
  203  0000816A 003C0001               OR.B      #1,CCR                ;point. Mark carry flag as success 
  204  0000816E 4E75                   RTS                             ;and return 
  205  00008170 023C00FE     SRCH7:    AND.B     #$FE,CCR              ;Fail - clear carry to indicate 
  206  00008174 4E75                   RTS                             ;command not found and return 
  207                        * 
  208                        ************************************************************************* 
  209                        * 
  210                        *  Basic input routines 
  211                        *  HEX    =  Get one   hexadecimal character  into D0 
  212                        *  BYTE   =  Get two   hexadecimal characters into D0 
  213                        *  WORD   =  Get four  hexadecimal characters into D0 
  214                        *  LONGWD =  Get eight hexadecimal characters into D0 
  215                        *  PARAM  =  Get a longword from the line buffer into D0 
  216                        *  Bit 0 of D7 is set to indicate a hexadecimal input error 
  217                        * 
  218  00008176 610003E6     HEX:      BSR       GETCHAR               ;Get a character from input device 
  219  0000817A 04000030               SUB.B     #$30,D0               ;Convert to binary 
  220  0000817E 6B0E                   BMI.S     NOT_HEX               ;If less than $30 then exit with error 
  221  00008180 0C000009               CMP.B     #$09,D0               ;Else test for number (0 to 9) 
  222  00008184 6F0C                   BLE.S     HEX_OK                ;If number then exit - success 
  223  00008186 5F00                   SUB.B     #$07,D0               ;Else convert letter to hex 
  224  00008188 0C00000F               CMP.B     #$0F,D0               ;If character in range "A" to "F" 
  225  0000818C 6F04                   BLE.S     HEX_OK                ;then exit successfully 
  226  0000818E 00070001     NOT_HEX:  OR.B      #1,D7                 ;Else set error flag 
  227  00008192 4E75         HEX_OK:   RTS                             ;and return 
  228                        * 
  229  00008194 2F01         BYTE:     MOVE.L    D1,-(A7)              ;Save D1 
  230  00008196 61DE                   BSR       HEX                   ;Get first hex character 
  231  00008198 E900                   ASL.B     #4,D0                 ;Move it to MS nybble position 
  232  0000819A 1200                   MOVE.B    D0,D1                 ;Save MS nybble in D1 
  233  0000819C 61D8                   BSR       HEX                   ;Get second hex character 
  234  0000819E D001                   ADD.B     D1,D0                 ;Merge MS and LS nybbles 
  235  000081A0 221F                   MOVE.L    (A7)+,D1              ;Restore D1 
  236  000081A2 4E75                   RTS       
  237                        * 
  238  000081A4 61EE         WORD:     BSR       BYTE                  ;Get upper order byte 
  239  000081A6 E140                   ASL.W     #8,D0                 ;Move it to MS position 
  240  000081A8 60EA                   BRA       BYTE                  ;Get LS byte and return 
  241                        * 
  242  000081AA 61F8         LONGWD:   BSR       WORD                  ;Get upper order word 
  243  000081AC 4840                   SWAP      D0                    ;Move it to MS position 
  244  000081AE 60F4                   BRA       WORD                  ;Get lower order word and return 
  245                        * 
  246                        *  PARAM reads a parameter from the line buffer and puts it in both 
  247                        *  PARAMTR(A6) and D0. Bit 1 of D7 is set on error. 
  248                        * 
  249  000081B0 2F01         PARAM:    MOVE.L    D1,-(A7)              ;Save D1 
  250  000081B2 4281                   CLR.L     D1                    ;Clear input accumulator 
  251  000081B4 206E0040               MOVE.L    BUFFPT(A6),A0         ;A0 points to parameter in buffer 
  252  000081B8 1018         PARAM1:   MOVE.B    (A0)+,D0              ;Read character from line buffer 
  253  000081BA 0C000020               CMP.B     #SPACE,D0             ;Test for delimiter 
  254  000081BE 6720                   BEQ.S     PARAM4                ;The permitted delimiter is a 
  255  000081C0 0C00000D               CMP.B     #CR,D0                ;space or a carriage return 
  256  000081C4 671A                   BEQ.S     PARAM4                ;Exit on either space or C/R 
  257  000081C6 E981                   ASL.L     #4,D1                 ;Shift accumulated result 4 bits left 
  258  000081C8 04000030               SUB.B     #$30,D0               ;Convert new character to hex 
  259  000081CC 6B1E                   BMI.S     PARAM5                ;If less than $30 then not-hex 
  260  000081CE 0C000009               CMP.B     #$09,D0               ;If less than 10 
  261  000081D2 6F08                   BLE.S     PARAM3                ;then continue 
  262  000081D4 5F00                   SUB.B     #$07,D0               ;Else assume $A - $F 
  263  000081D6 0C00000F               CMP.B     #$0F,D0               ;If more than $F 
  264  000081DA 6E10                   BGT.S     PARAM5                ;then exit to error on not-hex 
  265  000081DC D200         PARAM3:   ADD.B     D0,D1                 ;Add latest nybble to total in D1 
  266  000081DE 60D8                   BRA       PARAM1                ;Repeat until delimiter found 
  267  000081E0 2D480040     PARAM4:   MOVE.L    A0,BUFFPT(A6)         ;Save pointer in memory 
  268  000081E4 2D410044               MOVE.L    D1,PARAMTR(A6)        ;Save parameter in memory 
  269  000081E8 2001                   MOVE.L    D1,D0                 ;Put parameter in D0 for return 
  270  000081EA 6004                   BRA.S     PARAM6                ;Return without error 
  271  000081EC 00070002     PARAM5:   OR.B      #2,D7                 ;Set error flag before return 
  272  000081F0 221F         PARAM6:   MOVE.L    (A7)+,D1              ;Restore working register 
  273  000081F2 4E75                   RTS                             ;Return with error 
  274                        * 
  275                        ************************************************************************* 
  276                        * 
  277                        *  Output routines 
  278                        *  OUT1X   = print one   hexadecimal character 
  279                        *  OUT2X   = print two   hexadecimal characters 
  280                        *  OUT4X   = print four  hexadecimal characters 
  281                        *  OUT8X   = print eight hexadecimal characters 
  282                        *  In each case, the data to be printed is in D0 
  283                        * 
  284  000081F4 3F00         OUT1X:    MOVE.W    D0,-(A7)              ;Save D0 
  285  000081F6 0200000F               AND.B     #$0F,D0               ;Mask off MS nybble 
  286  000081FA 06000030               ADD.B     #$30,D0               ;Convert to ASCII 
  287  000081FE 0C000039               CMP.B     #$39,D0               ;ASCII = HEX + $30 
  288  00008202 6302                   BLS.S     OUT1X1                ;If ASCII <= $39 then print and exit 
  289  00008204 5E00                   ADD.B     #$07,D0               ;Else ASCII := HEX + 7 
  290  00008206 61000388     OUT1X1:   BSR       PUTCHAR               ;Print the character 
  291  0000820A 301F                   MOVE.W    (A7)+,D0              ;Restore D0 
  292  0000820C 4E75                   RTS       
  293                        * 
  294  0000820E E818         OUT2X:    ROR.B     #4,D0                 ;Get MS nybble in LS position 
  295  00008210 61E2                   BSR       OUT1X                 ;Print MS nybble 
  296  00008212 E918                   ROL.B     #4,D0                 ;Restore LS nybble 
  297  00008214 60DE                   BRA       OUT1X                 ;Print LS nybble and return 
  298                        * 
  299  00008216 E058         OUT4X:    ROR.W     #8,D0                 ;Get MS byte in LS position 
  300  00008218 61F4                   BSR       OUT2X                 ;Print MS byte 
  301  0000821A E158                   ROL.W     #8,D0                 ;Restore LS byte 
  302  0000821C 60F0                   BRA       OUT2X                 ;Print LS byte and return 
  303                        * 
  304  0000821E 4840         OUT8X:    SWAP      D0                    ;Get MS word in LS position 
  305  00008220 61F4                   BSR       OUT4X                 ;Print MS word 
  306  00008222 4840                   SWAP      D0                    ;Restore LS word 
  307  00008224 60F0                   BRA       OUT4X                 ;Print LS word and return 
  308                        * 
  309                        ************************************************************************* 
  310                        * 
  311                        * JUMP causes execution to begin at the address in the line buffer 
  312                        * 
  313  00008226 6188         JUMP:     BSR       PARAM                 ;Get address from buffer 
  314  00008228 4A07                   TST.B     D7                    ;Test for input error 
  315  0000822A 6608                   BNE.S     JUMP1                 ;If error flag not zero then exit 
  316  0000822C 4A80                   TST.L     D0                    ;Else test for missing address 
  317  0000822E 6704                   BEQ.S     JUMP1                 ;field. If no address then exit 
  318  00008230 2040                   MOVE.L    D0,A0                 ;Put jump address in A0 and call the 
  319  00008232 4ED0                   JMP       (A0)                  ;subroutine. User to supply RTS!! 
  320  00008234 49FA08A1     JUMP1:    LEA.L     ERMES1(PC),A4         ;Here for error - display error 
  321  00008238 6000FE42               BRA       PSTRING               ;message and return 
  322                        * 
  323                        ************************************************************************* 
  324                        * 
  325                        *  Display the contents of a memory location and modify it 
  326                        * 
  327  0000823C 6100FF72     MEMORY:   BSR       PARAM                 ;Get start address from line buffer 
  328  00008240 4A07                   TST.B     D7                    ;Test for input error 
  329  00008242 6634                   BNE.S     MEM3                  ;If error then exit 
  330  00008244 2640                   MOVE.L    D0,A3                 ;A3 points to location to be opened 
  331  00008246 6100FE24     MEM1:     BSR       NEWLINE
  332  0000824A 612E                   BSR.S     ADR_DAT               ;Print current address and contents 
  333  0000824C 6140                   BSR.S     PSPACE                ;update pointer, A3, and O/P space 
  334  0000824E 6100030E               BSR       GETCHAR               ;Input char to decide next action 
  335  00008252 0C00000D               CMP.B     #CR,D0                ;If carriage return then exit 
  336  00008256 6720                   BEQ.S     MEM3                  ;Exit 
  337  00008258 0C00002D               CMP.B     #'-',D0               ;If "-" then move back 
  338  0000825C 6606                   BNE.S     MEM2                  ;Else skip wind-back procedure 
  339  0000825E 47EBFFFC               LEA.L     -4(A3),A3             ;Move pointer back 2+2 
  340  00008262 60E2                   BRA       MEM1                  ;Repeat until carriage return 
  341  00008264 0C000020     MEM2:     CMP.B     #SPACE,D0             ;Test for space (= new entry) 
  342  00008268 66DC                   BNE.S     MEM1                  ;If not space then repeat 
  343  0000826A 6100FF38               BSR       WORD                  ;Else get new word to store 
  344  0000826E 4A07                   TST.B     D7                    ;Test for input error 
  345  00008270 6606                   BNE.S     MEM3                  ;If error then exit 
  346  00008272 3740FFFE               MOVE.W    D0,-2(A3)             ;Store new word 
  347  00008276 60CE                   BRA       MEM1                  ;Repeat until carriage return 
  348  00008278 4E75         MEM3:     RTS       
  349                        * 
  350  0000827A 2F00         ADR_DAT:  MOVE.L    D0,-(A7)              ;Print the contents of A3 and the 
  351  0000827C 200B                   MOVE.L    A3,D0                 ;word pointed at by A3. 
  352  0000827E 619E                   BSR       OUT8X                 ;and print current address 
  353  00008280 610C                   BSR.S     PSPACE                ;Insert delimiter 
  354  00008282 3013                   MOVE.W    (A3),D0               ;Get data at this address in D0 
  355  00008284 6190                   BSR       OUT4X                 ;and print it 
  356  00008286 47EB0002               LEA.L     2(A3),A3              ;Point to next address to display 
  357  0000828A 201F                   MOVE.L    (A7)+,D0              ;Restore D0 
  358  0000828C 4E75                   RTS       
  359                        * 
  360  0000828E 1F00         PSPACE:   MOVE.B    D0,-(A7)              ;Print a single space 
  361  00008290 103C0020               MOVE.B    #SPACE,D0
  362  00008294 610002FA               BSR       PUTCHAR
  363  00008298 101F                   MOVE.B    (A7)+,D0
  364  0000829A 4E75                   RTS       
  365                        * 
  366                        ************************************************************************* 
  367                        * 
  368                        *  LOAD  Loads data formatted in hexadecimal "S" format from Port 2 
  369                        *        NOTE - I/O is automatically redirected to the aux port for 
  370                        *        loader functions. S1 or S2 records accepted 
  371                        * 
  372  0000829C 2F2E0052     LOAD:     MOVE.L    CN_OVEC(A6),-(A7)     ;Save current output device name 
  373  000082A0 2F2E004E               MOVE.L    CN_IVEC(A6),-(A7)     ;Save current input device name 
  374  000082A4 2D7C00008C22           MOVE.L    #DCB4,CN_OVEC(A6)     ;Set up aux ACIA as output 
                0052        
  375  000082AC 2D7C00008C10           MOVE.L    #DCB3,CN_IVEC(A6)     ;Set up aux ACIA as input 
                004E        
  376  000082B4 522E0048               ADD.B     #1,ECHO(A6)           ;Turn off character echo 
  377  000082B8 6100FDB2               BSR       NEWLINE               ;Send newline to host 
  378  000082BC 6100015A               BSR       DELAY                 ;Wait for host to "settle" 
  379  000082C0 61000156               BSR       DELAY
  380  000082C4 286E0040               MOVE.L    BUFFPT(A6),A4         ;Any string in the line buffer is 
  381  000082C8 101C         LOAD1:    MOVE.B    (A4)+,D0              ;transmitted to the host computer 
  382  000082CA 610002C4               BSR       PUTCHAR               ;before the loading begins 
  383  000082CE 0C00000D               CMP.B     #CR,D0                ;Read from the buffer until EOL 
  384  000082D2 66F4                   BNE       LOAD1
  385  000082D4 6100FD96               BSR       NEWLINE               ;Send newline before loading 
  386  000082D8 61000284     LOAD2:    BSR       GETCHAR               ;Records from the host must begin 
  387  000082DC 0C000053               CMP.B     #'S',D0               ;with S1/S2 (data) or S9/S8 (term) 
  388  000082E0 66F6                   BNE.S     LOAD2                 ;Repeat GETCHAR until char = "S" 
  389  000082E2 6100027A               BSR       GETCHAR               ;Get character after "S" 
  390  000082E6 0C000039               CMP.B     #'9',D0               ;Test for the two terminators S9/S8 
  391  000082EA 6706                   BEQ.S     LOAD3                 ;If S9 record then exit else test 
  392  000082EC 0C000038               CMP.B     #'8',D0               ;for S8 terminator. Fall through to 
  393  000082F0 662A                   BNE.S     LOAD6                 ;exit on S8 else continue search 
  394           000082F2     LOAD3:    EQU       *                     ;Exit point from LOAD 
  395  000082F2 2D5F004E               MOVE.L    (A7)+,CN_IVEC(A6)     ;Clean up by restoring input device 
  396  000082F6 2D5F0052               MOVE.L    (A7)+,CN_OVEC(A6)     ;and output device name 
  397  000082FA 422E0048               CLR.B     ECHO(A6)              ;Restore input character echo 
  398  000082FE 08070000               BTST.B    #0,D7                 ;Test for input errors 
  399  00008302 6708                   BEQ.S     LOAD4                 ;If no I/P error then look at checksum 
  400  00008304 49FA07D1               LEA.L     ERMES1(PC),A4         ;Else point to error message 
  401  00008308 6100FD72               BSR       PSTRING               ;Print it 
  402  0000830C 08070003     LOAD4:    BTST.B    #3,D7                 ;Test for checksum error 
  403  00008310 6708                   BEQ.S     LOAD5                 ;If clear then exit 
  404  00008312 49FA07F3               LEA.L     ERMES3(PC),A4         ;Else point to error message 
  405  00008316 6100FD64               BSR       PSTRING               ;Print it and return 
  406  0000831A 4E75         LOAD5:    RTS       
  407                        * 
  408  0000831C 0C000031     LOAD6:    CMP.B     #'1',D0               ;Test for S1 record 
  409  00008320 671E                   BEQ.S     LOAD6A                ;If S1 record then read it 
  410  00008322 0C000032               CMP.B     #'2',D0               ;Else test for S2 record 
  411  00008326 66B0                   BNE.S     LOAD2                 ;Repeat until valid header found 
  412  00008328 4203                   CLR.B     D3                    ;Read the S2 byte count and address, 
  413  0000832A 613C                   BSR.S     LOAD8                 ;clear the checksum 
  414  0000832C 5900                   SUB.B     #4,D0                 ;Calculate size of data field 
  415  0000832E 1400                   MOVE.B    D0,D2                 ;D2 contains data bytes to read 
  416  00008330 4280                   CLR.L     D0                    ;Clear address accumulator 
  417  00008332 6134                   BSR.S     LOAD8                 ;Read most sig byte of address 
  418  00008334 E180                   ASL.L     #8,D0                 ;Move it one byte left 
  419  00008336 6130                   BSR.S     LOAD8                 ;Read the middle byte of address 
  420  00008338 E180                   ASL.L     #8,D0                 ;Move it one byte left 
  421  0000833A 612C                   BSR.S     LOAD8                 ;Read least sig byte of address 
  422  0000833C 2440                   MOVE.L    D0,A2                 ;A2 points to destination of record 
  423  0000833E 6012                   BRA.S     LOAD7                 ;Skip past S1 header loader 
  424  00008340 4203         LOAD6A:   CLR.B     D3                    ;S1 record found - clear checksum 
  425  00008342 6124                   BSR.S     LOAD8                 ;Get byte and update checksum 
  426  00008344 5700                   SUB.B     #3,D0                 ;Subtract 3 from record length 
  427  00008346 1400                   MOVE.B    D0,D2                 ;Save byte count in D2 
  428  00008348 4280                   CLR.L     D0                    ;Clear address accumulator 
  429  0000834A 611C                   BSR.S     LOAD8                 ;Get MS byte of load address 
  430  0000834C E180                   ASL.L     #8,D0                 ;Move it to MS position 
  431  0000834E 6118                   BSR.S     LOAD8                 ;Get LS byte in D2 
  432  00008350 2440                   MOVE.L    D0,A2                 ;A2 points to destination of data 
  433  00008352 6114         LOAD7:    BSR.S     LOAD8                 ;Get byte of data for loading 
  434  00008354 14C0                   MOVE.B    D0,(A2)+              ;Store it 
  435  00008356 5302                   SUB.B     #1,D2                 ;Decrement byte counter 
  436  00008358 66F8                   BNE       LOAD7                 ;Repeat until count = 0 
  437  0000835A 610C                   BSR.S     LOAD8                 ;Read checksum 
  438  0000835C 5203                   ADD.B     #1,D3                 ;Add 1 to total checksum 
  439  0000835E 6700FF78               BEQ       LOAD2                 ;If zero then start next record 
  440  00008362 00070008               OR.B      #%00001000,D7         ;Else set checksum error bit, 
  441  00008366 608A                   BRA       LOAD3                 ;restore I/O devices and return 
  442                        * 
  443  00008368 6100FE2A     LOAD8:    BSR       BYTE                  ;Get a byte 
  444  0000836C D600                   ADD.B     D0,D3                 ;Update checksum 
  445  0000836E 4E75                   RTS                             ;and return 
  446                        * 
  447                        ************************************************************************* 
  448                        * 
  449                        *  DUMP   Transmit S1 formatted records to host computer 
  450                        *         A3 = Starting address of data block 
  451                        *         A2 = End address of data block 
  452                        *         D1 = Checksum, D2 = current record length 
  453                        * 
  454  00008370 61000096     DUMP:     BSR       RANGE                 ;Get start and end address 
  455  00008374 4A07                   TST.B     D7                    ;Test for input error 
  456  00008376 6708                   BEQ.S     DUMP1                 ;If no error then continue 
  457  00008378 49FA075D               LEA.L     ERMES1(PC),A4         ;Else point to error message, 
  458  0000837C 6000FCFE               BRA       PSTRING               ;print it and return 
  459  00008380 B08B         DUMP1:    CMP.L     A3,D0                 ;Compare start and end addresses 
  460  00008382 6A08                   BPL.S     DUMP2                 ;If positive then start < end 
  461  00008384 49FA07D1               LEA.L     ERMES7(PC),A4         ;Else print error message 
  462  00008388 6000FCF2               BRA       PSTRING               ;and return 
  463  0000838C 2F2E0052     DUMP2:    MOVE.L    CN_OVEC(A6),-(A7)     ;Save name of current output device 
  464  00008390 2D7C00008C22           MOVE.L    #DCB4,CN_OVEC(A6)     ;Set up Port 2 as output device 
                0052        
  465  00008398 6100FCD2               BSR       NEWLINE               ;Send newline to host and wait 
  466  0000839C 617A                   BSR.S     DELAY
  467  0000839E 286E0040               MOVE.L    BUFFPT(A6),A4         ;Before dumping, send any string 
  468  000083A2 101C         DUMP3:    MOVE.B    (A4)+,D0              ;in the input buffer to the host 
  469  000083A4 610001EA               BSR       PUTCHAR               ;Repeat 
  470  000083A8 0C00000D               CMP.B     #CR,D0                ;Transmit char from buffer to host 
  471  000083AC 66F4                   BNE       DUMP3                 ;Until char = C/R 
  472  000083AE 6100FCBC               BSR       NEWLINE
  473  000083B2 6164                   BSR.S     DELAY                 ;Allow time for host to settle 
  474  000083B4 528A                   ADDQ.L    #1,A2                 ;A2 contains length of record + 1 
  475  000083B6 240A         DUMP4:    MOVE.L    A2,D2                 ;D2 points to end address 
  476  000083B8 948B                   SUB.L     A3,D2                 ;D2 contains bytes left to print 
  477  000083BA 0C8200000011           CMP.L     #17,D2                ;If this is not a full record of 16 
  478  000083C0 6502                   BCS.S     DUMP5                 ;then load D2 with record size 
  479  000083C2 7410                   MOVEQ     #16,D2                ;Else preset byte count to 16 
  480  000083C4 49FA064C     DUMP5:    LEA.L     HEADER(PC),A4         ;Point to record header 
  481  000083C8 6100FCB2               BSR       PSTRING               ;Print header 
  482  000083CC 4201                   CLR.B     D1                    ;Clear checksum 
  483  000083CE 1002                   MOVE.B    D2,D0                 ;Move record length to output register 
  484  000083D0 5600                   ADD.B     #3,D0                 ;Length includes address + count 
  485  000083D2 612E                   BSR.S     DUMP7                 ;Print number of bytes in record 
  486  000083D4 200B                   MOVE.L    A3,D0                 ;Get start address to be printed 
  487  000083D6 E158                   ROL.W     #8,D0                 ;Get MS byte in LS position 
  488  000083D8 6128                   BSR.S     DUMP7                 ;Print MS byte of address 
  489  000083DA E058                   ROR.W     #8,D0                 ;Restore LS byte 
  490  000083DC 6124                   BSR.S     DUMP7                 ;Print LS byte of address 
  491  000083DE 101B         DUMP6:    MOVE.B    (A3)+,D0              ;Get data byte to be printed 
  492  000083E0 6120                   BSR.S     DUMP7                 ;Print it 
  493  000083E2 5302                   SUB.B     #1,D2                 ;Decrement byte count 
  494  000083E4 66F8                   BNE       DUMP6                 ;Repeat until all this record printed 
  495  000083E6 4601                   NOT.B     D1                    ;Complement checksum 
  496  000083E8 1001                   MOVE.B    D1,D0                 ;Move to output register 
  497  000083EA 6116                   BSR.S     DUMP7                 ;Print checksum 
  498  000083EC 6100FC7E               BSR       NEWLINE
  499  000083F0 B7CA                   CMP.L     A2,A3                 ;Have all records been printed? 
  500  000083F2 66C2                   BNE       DUMP4                 ;Repeat until all done 
  501  000083F4 49FA0622               LEA.L     TAIL(PC),A4           ;Point to message tail (S9 record) 
  502  000083F8 6100FC82               BSR       PSTRING               ;Print it 
  503  000083FC 2D5F0052               MOVE.L    (A7)+,CN_OVEC(A6)     ;Restore name of output device 
  504  00008400 4E75                   RTS                             ;and return 
  505                        * 
  506  00008402 D200         DUMP7:    ADD.B     D0,D1                 ;Update checksum, transmit byte 
  507  00008404 6000FE08               BRA       OUT2X                 ;to host and return 
  508                        * 
  509           00008408     RANGE:    EQU       *                     ;Get the range of addresses to be 
  510  00008408 4207                   CLR.B     D7                    ;transmitted from the buffer 
  511  0000840A 6100FDA4               BSR       PARAM                 ;Get starting address 
  512  0000840E 2640                   MOVE.L    D0,A3                 ;Set up start address in A3 
  513  00008410 6100FD9E               BSR       PARAM                 ;Get end address 
  514  00008414 2440                   MOVE.L    D0,A2                 ;Set up end address in A2 
  515  00008416 4E75                   RTS       
  516                        * 
  517           00008418     DELAY:    EQU       *                     ;Provide a time delay for the host 
  518  00008418 48E78008               MOVEM.L   D0/A4,-(A7)           ;to settle. Save working registers 
  519  0000841C 203C00004000           MOVE.L    #$4000,D0             ;Set up delay constant 
  520  00008422 5380         DELAY1:   SUB.L     #1,D0                 ;Count down         (8 clk cycles) 
  521  00008424 66FC                   BNE       DELAY1                ;Repeat until zero  (10 clk cycles) 
  522  00008426 4CDF1001               MOVEM.L   (A7)+,D0/A4           ;Restore working registers 
  523  0000842A 4E75                   RTS       
  524                        * 
  525                        ************************************************************************* 
  526                        * 
  527                        *  TM  Enter transparant mode (All communication to go from terminal to 
  528                        *  the host processor until escape sequence entered). End sequence 
  529                        *  = ESC, E. A newline is sent to the host to "clear it down". 
  530                        * 
  531  0000842C 13FC00550001 TM:       MOVE.B    #$55,ACIA_1           ;Force RTS* high to re-route data 
                0040        
  532  00008434 522E0048               ADD.B     #1,ECHO(A6)           ;Turn off character echo 
  533  00008438 61000124     TM1:      BSR       GETCHAR               ;Get character 
  534  0000843C 0C00001B               CMP.B     #ESC,D0               ;Test for end of TM mode 
  535  00008440 66F6                   BNE       TM1                   ;Repeat until first escape character 
  536  00008442 6100011A               BSR       GETCHAR               ;Get second character 
  537  00008446 0C000045               CMP.B     #'E',D0               ;If second char = E then exit TM 
  538  0000844A 66EC                   BNE       TM1                   ;Else continue 
  539  0000844C 2F2E0052               MOVE.L    CN_OVEC(A6),-(A7)     ;Save output port device name 
  540  00008450 2D7C00008C22           MOVE.L    #DCB4,CN_OVEC(A6)     ;Get name of host port (aux port) 
                0052        
  541  00008458 6100FC12               BSR       NEWLINE               ;Send newline to host to clear it 
  542  0000845C 2D5F0052               MOVE.L    (A7)+,CN_OVEC(A6)     ;Restore output device port name 
  543  00008460 422E0048               CLR.B     ECHO(A6)              ;Restore echo mode 
  544  00008464 13FC00150001           MOVE.B    #$15,ACIA_1           ;Restore normal ACIA mode (RTS* low) 
                0040        
  545  0000846C 4E75                   RTS       
  546                        * 
  547                        ************************************************************************* 
  548                        * 
  549                        *  This routine sets up the system DCBs in RAM using the information 
  550                        *  stored in ROM at address DCB_LST. This is called at initialization. 
  551                        *  CN_IVEC contains the name "DCB1" and IO_VEC the name "DCB2" 
  552                        * 
  553  0000846E 48E7F0F0     SET_DCB:  MOVEM.L   A0-A3/D0-D3,-(A7)     ;Save all working registers 
  554  00008472 41EE00D0               LEA.L     FIRST(A6),A0          ;Pointer to first DCB destination in RAM 
  555  00008476 43FA0774               LEA.L     DCB_LST(PC),A1        ;A1 points to DCB info block in ROM 
  556  0000847A 303C0005               MOVE.W    #5,D0                 ;6 DCBs to set up 
  557  0000847E 323C000F     ST_DCB1:  MOVE.W    #15,D1                ;16 bytes to move per DCB header 
  558  00008482 10D9         ST_DCB2:  MOVE.B    (A1)+,(A0)+           ;Move the 16 bytes of a DCB header 
  559  00008484 51C9FFFC               DBRA      D1,ST_DCB2            ;from ROM to RAM 
  560  00008488 3619                   MOVE.W    (A1)+,D3              ;Get size of parameter block (bytes) 
  561  0000848A 3083                   MOVE.W    D3,(A0)               ;Store size in DCB in RAM 
  562  0000848C 41F03002               LEA.L     2(A0,D3.W),A0         ;A0 points to tail of DCB in RAM 
  563  00008490 47E80004               LEA.L     4(A0),A3              ;A3 contains address of next DCB in RAM 
  564  00008494 208B                   MOVE.L    A3,(A0)               ;Store pointer to next DCB in this DCB 
  565  00008496 41D3                   LEA.L     (A3),A0               ;A0 now points at next DCB in RAM 
  566  00008498 51C8FFE4               DBRA      D0,ST_DCB1            ;Repeat until all DCBs set up 
  567  0000849C 47EBFFFC               LEA.L     -4(A3),A3             ;Adjust A3 to point to last DCB pointer 
  568  000084A0 4293                   CLR.L     (A3)                  ;and force last pointer to zero 
  569  000084A2 2D7C00008BEC           MOVE.L    #DCB1,CN_IVEC(A6)     ;Set up vector to console input DCB 
                004E        
  570  000084AA 2D7C00008BFE           MOVE.L    #DCB2,CN_OVEC(A6)     ;Set up vector to console output DCB 
                0052        
  571  000084B2 4CDF0F0F               MOVEM.L   (A7)+,A0-A3/D0-D3     ;Restore registers 
  572  000084B6 4E75                   RTS       
  573                        * 
  574                        ************************************************************************* 
  575                        * 
  576                        *  IO_REQ handles all input/output transactions. A0 points to DCB on 
  577                        *  entry. IO_REQ calls the device driver whose address is in the DCB. 
  578                        * 
  579  000084B8 48E700C0     IO_REQ:   MOVEM.L   A0-A1,-(A7)           ;Save working registers 
  580  000084BC 43E80008               LEA.L     8(A0),A1              ;A1 points to device handler field in DCB 
  581  000084C0 2251                   MOVE.L    (A1),A1               ;A1 contains device handler address 
  582  000084C2 4E91                   JSR       (A1)                  ;Call device handler 
  583  000084C4 4CDF0300               MOVEM.L   (A7)+,A0-A1           ;Restore working registers 
  584  000084C8 4E75                   RTS       
  585                        * 
  586                        ************************************************************************* 
  587                        * 
  588                        *  CON_IN handles input from the console device 
  589                        *  This is the device driver used by DCB1. Exit with input in D0 
  590                        * 
  591  000084CA 48E74040     CON_IN:   MOVEM.L   D1/A1,-(A7)           ;Save working registers 
  592  000084CE 43E8000C               LEA.L     12(A0),A1             ;Get pointer to ACIA from DCB 
  593  000084D2 2251                   MOVE.L    (A1),A1               ;Get address of ACIA in A1 
  594  000084D4 42280013               CLR.B     19(A0)                ;Clear logical error in DCB 
  595  000084D8 1211         CON_I1:   MOVE.B    (A1),D1               ;Read ACIA status 
  596  000084DA 08010000               BTST.B    #0,D1                 ;Test RDRF 
  597  000084DE 67F8                   BEQ       CON_I1                ;Repeat until RDRF true 
  598  000084E0 11410012               MOVE.B    D1,18(A0)             ;Store physical status in DCB 
  599  000084E4 020100F4               AND.B     #%011110100,D1        ;Mask to input error bits 
  600  000084E8 6706                   BEQ.S     CON_I2                ;If no error then skip update 
  601  000084EA 117C00010013           MOVE.B    #1,19(A0)             ;Else update logical error 
  602  000084F0 10290002     CON_I2:   MOVE.B    2(A1),D0              ;Read input from ACIA 
  603  000084F4 4CDF0202               MOVEM.L   (A7)+,A1/D1           ;Restore working registers 
  604  000084F8 4E75                   RTS       
  605                        * 
  606                        ************************************************************************* 
  607                        * 
  608                        *   This is the device driver used by DCB2. Output in D0 
  609                        *   The output can be halted or suspended 
  610                        * 
  611  000084FA 48E76040     CON_OUT:  MOVEM.L   A1/D1-D2,-(A7)        ;Save working registers 
  612  000084FE 43E8000C               LEA.L     12(A0),A1             ;Get pointer to ACIA from DCB 
  613  00008502 2251                   MOVE.L    (A1),A1               ;Get address of ACIA in A1 
  614  00008504 42280013               CLR.B     19(A0)                ;Clear logical error in DCB 
  615  00008508 1211         CON_OT1:  MOVE.B    (A1),D1               ;Read ACIA status 
  616  0000850A 08010000               BTST.B    #0,D1                 ;Test RDRF bit (any input?) 
  617  0000850E 6716                   BEQ.S     CON_OT3               ;If no input then test output status 
  618  00008510 14290002               MOVE.B    2(A1),D2              ;Else read the input 
  619  00008514 0202005F               AND.B     #%01011111,D2         ;Strip parity and bit 5 
  620  00008518 0C020057               CMP.B     #WAIT,D2              ;and test for a wait condition 
  621  0000851C 6608                   BNE.S     CON_OT3               ;If not wait then ignore and test O/P 
  622  0000851E 1411         CON_OT2:  MOVE.B    (A1),D2               ;Else read ACIA status register 
  623  00008520 08020000               BTST.B    #0,D2                 ;and poll ACIA until next char received 
  624  00008524 67F8                   BEQ       CON_OT2
  625  00008526 08010001     CON_OT3:  BTST.B    #1,D1                 ;Repeat 
  626  0000852A 67DC                   BEQ       CON_OT1               ;until ACIA Tx ready 
  627  0000852C 11410012               MOVE.B    D1,18(A0)             ;Store status in DCB physical error 
  628  00008530 13400002               MOVE.B    D0,2(A1)              ;Transmit output 
  629  00008534 4CDF0206               MOVEM.L   (A7)+,A1/D1-D2        ;Restore working registers 
  630  00008538 4E75                   RTS       
  631                        * 
  632                        ************************************************************************* 
  633                        * 
  634                        *  AUX_IN and AUX_OUT are simplified versions of CON_IN and 
  635                        *  CON_OUT for use with the port to the host processor 
  636                        * 
  637  0000853A 43E8000C     AUX_IN:   LEA.L     12(A0),A1             ;Get pointer to aux ACIA from DCB 
  638  0000853E 2251                   MOVE.L    (A1),A1               ;Get address of aux ACIA 
  639  00008540 08110000     AUX_IN1:  BTST.B    #0,(A1)               ;Test for data ready 
  640  00008544 67FA                   BEQ       AUX_IN1               ;Repeat until ready 
  641  00008546 10290002               MOVE.B    2(A1),D0              ;Read input 
  642  0000854A 4E75                   RTS       
  643                        * 
  644  0000854C 43E8000C     AUX_OUT:  LEA.L     12(A0),A1             ;Get pointer to aux ACIA from DCB 
  645  00008550 2251                   MOVE.L    (A1),A1               ;Get address of aux ACIA 
  646  00008552 08110001     AUX_OT1:  BTST.B    #1,(A1)               ;Test for ready to transmit 
  647  00008556 67FA                   BEQ       AUX_OT1               ;Repeat until transmitter ready 
  648  00008558 13400002               MOVE.B    D0,2(A1)              ;Transmit data 
  649  0000855C 4E75                   RTS       
  650                        * 
  651                        ************************************************************************* 
  652                        * 
  653                        *  GETCHAR gets a character from the console device 
  654                        *  This is the main input routine and uses the device whose name  
  655                        *  is stored in CN_IVEC. Changing this name redirects input. 
  656                        * 
  657  0000855E 2F08         GETCHAR:  MOVE.L    A0,-(A7)              ;Save working register 
  658  00008560 206E004E               MOVE.L    CN_IVEC(A6),A0        ;A0 points to name of console DCB 
  659  00008564 6154                   BSR.S     IO_OPEN               ;Open console (get DCB address in A0) 
  660  00008566 08070003               BTST.B    #3,D7                 ;D7(3) set if open error 
  661  0000856A 6620                   BNE.S     GETCH3                ;If error then exit now 
  662  0000856C 6100FF4A               BSR       IO_REQ                ;Else execute I/O transaction 
  663  00008570 0200007F               AND.B     #$7F,D0               ;Strip msb of input 
  664  00008574 4A2E0049               TST.B     U_CASE(A6)            ;Test for upper -> lower case conversion 
  665  00008578 660A                   BNE.S     GETCH2                ;If flag not zero do not convert case 
  666  0000857A 08000006               BTST.B    #6,D0                 ;Test input for lower case 
  667  0000857E 6704                   BEQ.S     GETCH2                ;If upper case then skip conversion 
  668  00008580 020000DF               AND.B     #%11011111,D0         ;Else clear bit 5 for upper case conv 
  669  00008584 4A2E0048     GETCH2:   TST.B     ECHO(A6)              ;Do we need to echo the input? 
  670  00008588 6602                   BNE.S     GETCH3                ;If ECHO not zero then no echo 
  671  0000858A 6104                   BSR.S     PUTCHAR               ;Else echo the input 
  672  0000858C 205F         GETCH3:   MOVE.L    (A7)+,A0              ;Restore working register 
  673  0000858E 4E75                   RTS                             ;and return 
  674                        * 
  675                        ************************************************************************* 
  676                        * 
  677                        *  PUTCHAR sends a character to the console device 
  678                        *  The name of the output device is in CN_OVEC. 
  679                        * 
  680  00008590 2F08         PUTCHAR:  MOVE.L    A0,-(A7)              ;Save working register 
  681  00008592 206E0052               MOVE.L    CN_OVEC(A6),A0        ;A0 points to name of console output 
  682  00008596 6122                   BSR.S     IO_OPEN               ;Open console (Get address of DCB) 
  683  00008598 6100FF1E               BSR       IO_REQ                ;Perform output with DCB pointed at by A0 
  684  0000859C 205F                   MOVE.L    (A7)+,A0              ;Restore working register 
  685  0000859E 4E75                   RTS       
  686                        * 
  687                        ************************************************************************* 
  688                        * 
  689                        *  BUFF_IN and BUFF_OUT are two rudimentary input and output routines 
  690                        *  which input data from and output data to a buffer in RAM. These are 
  691                        *  used by DCB5 and DCB6, respectively. 
  692                        * 
  693  000085A0 43E8000C     BUFF_IN:  LEA.L     12(A0),A1             ;A1 points to I/P buffer 
  694  000085A4 2451                   MOVE.L    (A1),A2               ;A2 gets I/P pointer from buffer 
  695  000085A6 1022                   MOVE.B    -(A2),D0              ;Read char from buffer and adjust A2 
  696  000085A8 228A                   MOVE.L    A2,(A1)               ;Restore pointer in buffer 
  697  000085AA 4E75                   RTS       
  698                        * 
  699  000085AC 43E8000C     BUFF_OT:  LEA.L     12(A0),A1             ;A1 points to O/P buffer 
  700  000085B0 24690004               MOVE.L    4(A1),A2              ;A2 gets O/P pointer from buffer 
  701  000085B4 14C0                   MOVE.B    D0,(A2)+              ;Store char in buffer and adjust A2 
  702  000085B6 228A                   MOVE.L    A2,(A1)               ;Restore pointer in buffer 
  703  000085B8 4E75                   RTS       
  704                        * 
  705                        ************************************************************************* 
  706                        * 
  707                        *  Open - opens a DCB for input or output. IO_OPEN converts the 
  708                        *  name pointed at by A0 into the address of the DCB pointed at 
  709                        *  by A0. Bit 3 of D7 is set to zero if DCB not found 
  710                        * 
  711  000085BA 48E7F870     IO_OPEN:  MOVEM.L   A1-A3/D0-D4,-(A7)     ;Save working registers 
  712  000085BE 43EE00D0               LEA.L     FIRST(A6),A1          ;A1 points to first DCB in chain in RAM 
  713  000085C2 45D1         OPEN1:    LEA.L     (A1),A2               ;A2 = temp copy of pointer to DCB 
  714  000085C4 47D0                   LEA.L     (A0),A3               ;A3 = temp copy of pointer to DCB name 
  715  000085C6 303C0007               MOVE.W    #7,D0                 ;Up to 8 chars of DCB name to match 
  716  000085CA 181A         OPEN2:    MOVE.B    (A2)+,D4              ;Compare DCB name with string 
  717  000085CC B81B                   CMP.B     (A3)+,D4
  718  000085CE 6608                   BNE.S     OPEN3                 ;If no match try next DCB 
  719  000085D0 51C8FFF8               DBRA      D0,OPEN2              ;Else repeat until all chars matched 
  720  000085D4 41D1                   LEA.L     (A1),A0               ;Success - move this DCB address to A0 
  721  000085D6 6016                   BRA.S     OPEN4                 ;and return 
  722           000085D8     OPEN3:    EQU       *                     ;Fail - calculate address of next DCB 
  723  000085D8 32290010               MOVE.W    16(A1),D1             ;Get parameter block size of DCB 
  724  000085DC 43F11012               LEA.L     18(A1,D1.W),A1        ;A1 points to pointer to next DCB 
  725  000085E0 2251                   MOVE.L    (A1),A1               ;A1 now points to next DCB 
  726  000085E2 B3FC00000000           CMP.L     #0,A1                 ;Test for end of DCB chain 
  727  000085E8 66D8                   BNE       OPEN1                 ;If not end of chain then try next DCB 
  728  000085EA 00070008               OR.B      #8,D7                 ;Else set error flag and return 
  729  000085EE 4CDF0E1F     OPEN4:    MOVEM.L   (A7)+,A1-A3/D0-D4     ;Restore working registers 
  730  000085F2 4E75                   RTS       
  731                        * 
  732                        ************************************************************************* 
  733                        * 
  734                        *  Exception vector table initialization routine 
  735                        *  All vectors not setup are loaded with uninitialized routine vector 
  736                        * 
  737  000085F4 41F80008     X_SET:    LEA.L     X_BASE,A0             ;Point to base of exception table 
  738  000085F8 303C00FD               MOVE.W    #253,D0               ;Number of vectors -  3 
  739  000085FC 20FC000089E4 X_SET1:   MOVE.L    #X_UN,(A0)+           ;Store uninitialized exception vector 
  740  00008602 51C8FFF8               DBRA      D0,X_SET1             ;Repeat until all entries preset 
  741  00008606 91C8                   SUB.L     A0,A0                 ;Clear A0 (points to vector table) 
  742  00008608 217C000087B4           MOVE.L    #BUS_ER,8(A0)         ;Setup bus error vector 
                0008        
  743  00008610 217C000087C2           MOVE.L    #ADD_ER,12(A0)        ;Setup address error vector 
                000C        
  744  00008618 217C0000879E           MOVE.L    #IL_ER,16(A0)         ;Setup illegal instruction error vect 
                0010        
  745  00008620 217C00008898           MOVE.L    #TRACE,36(A0)         ;Setup trace exception vector 
                0024        
  746  00008628 217C00008652           MOVE.L    #TRAP_0,128(A0)       ;Setup TRAP #0 exception vector 
                0080        
  747  00008630 217C000087D0           MOVE.L    #BRKPT,184(A0)        ;Setup TRAP #14 vector = breakpoint 
                00B8        
  748  00008638 217C00008040           MOVE.L    #WARM,188(A0)         ;Setup TRAP #15 exception vector 
                00BC        
  749  00008640 303C0007               MOVE.W    #7,D0                 ;Now clear the breakpoint table 
  750  00008644 41EE00A0               LEA.L     BP_TAB(A6),A0         ;Point to table 
  751  00008648 4298         X_SET2:   CLR.L     (A0)+                 ;Clear an address entry 
  752  0000864A 4258                   CLR.W     (A0)+                 ;Clear the corresponding data 
  753  0000864C 51C8FFFA               DBRA      D0,X_SET2             ;Repeat until all 8 cleared 
  754  00008650 4E75                   RTS       
  755                        * 
  756                        ************************************************************************* 
  757                        * 
  758           00008652     TRAP_0:   EQU       *                     ;User links to  TS2BUG via TRAP #0 
  759  00008652 0C010000               CMP.B     #0,D1                 ;D1 = 0 = Get character 
  760  00008656 6606                   BNE.S     TRAP1
  761  00008658 6100FF04               BSR       GETCHAR
  762  0000865C 4E73                   RTE       
  763  0000865E 0C010001     TRAP1:    CMP.B     #1,D1                 ;D1 = 1 = Print character 
  764  00008662 6606                   BNE.S     TRAP2
  765  00008664 6100FF2A               BSR       PUTCHAR
  766  00008668 4E73                   RTE       
  767  0000866A 0C010002     TRAP2:    CMP.B     #2,D1                 ;D1 = 2 = Newline 
  768  0000866E 6606                   BNE.S     TRAP3
  769  00008670 6100F9FA               BSR       NEWLINE
  770  00008674 4E73                   RTE       
  771  00008676 0C010003     TRAP3:    CMP.B     #3,D1                 ;D1 = 3 = Get parameter from buffer 
  772  0000867A 6606                   BNE.S     TRAP4
  773  0000867C 6100FB32               BSR       PARAM
  774  00008680 4E73                   RTE       
  775  00008682 0C010004     TRAP4:    CMP.B     #4,D1                 ;D1 = 4 = Print string pointed at by A4 
  776  00008686 6606                   BNE.S     TRAP5
  777  00008688 6100F9F2               BSR       PSTRING
  778  0000868C 4E73                   RTE       
  779  0000868E 0C010005     TRAP5:    CMP.B     #5,D1                 ;D1 = 5 = Get a hex character 
  780  00008692 6606                   BNE.S     TRAP6
  781  00008694 6100FAE0               BSR       HEX
  782  00008698 4E73                   RTE       
  783  0000869A 0C010006     TRAP6:    CMP.B     #6,D1                 ;D1 = 6 = Get a hex byte 
  784  0000869E 6606                   BNE.S     TRAP7
  785  000086A0 6100FAF2               BSR       BYTE
  786  000086A4 4E73                   RTE       
  787  000086A6 0C010007     TRAP7:    CMP.B     #7,D1                 ;D1 = 7 = Get a word 
  788  000086AA 6606                   BNE.S     TRAP8
  789  000086AC 6100FAF6               BSR       WORD
  790  000086B0 4E73                   RTE       
  791  000086B2 0C010008     TRAP8:    CMP.B     #8,D1                 ;D1 = 8 = Get a longword 
  792  000086B6 6606                   BNE.S     TRAP9
  793  000086B8 6100FAF0               BSR       LONGWD
  794  000086BC 4E73                   RTE       
  795  000086BE 0C010009     TRAP9:    CMP.B     #9,D1                 ;D1 = 9 = Output hex byte 
  796  000086C2 6606                   BNE.S     TRAP10
  797  000086C4 6100FB48               BSR       OUT2X
  798  000086C8 4E73                   RTE       
  799  000086CA 0C01000A     TRAP10:   CMP.B     #10,D1                ;D1 = 10 = Output hex word 
  800  000086CE 6606                   BNE.S     TRAP11
  801  000086D0 6100FB44               BSR       OUT4X
  802  000086D4 4E73                   RTE       
  803  000086D6 0C01000B     TRAP11:   CMP.B     #11,D1                ;D1 = 11 = Output hex longword 
  804  000086DA 6606                   BNE.S     TRAP12
  805  000086DC 6100FB40               BSR       OUT8X
  806  000086E0 4E73                   RTE       
  807  000086E2 0C01000C     TRAP12:   CMP.B     #12,D1                ;D1 = 12 = Print a space 
  808  000086E6 6606                   BNE.S     TRAP13
  809  000086E8 6100FBA4               BSR       PSPACE
  810  000086EC 4E73                   RTE       
  811  000086EE 0C01000D     TRAP13:   CMP.B     #13,D1                ;D1 = 13 = Get a line of text into 
  812  000086F2 6606                   BNE.S     TRAP14                ;the line buffer 
  813  000086F4 6100F99C               BSR       GETLINE
  814  000086F8 4E73                   RTE       
  815  000086FA 0C01000E     TRAP14:   CMP.B     #14,D1                ;D1 = 14 = Tidy up the line in the 
  816  000086FE 6606                   BNE.S     TRAP15                ;line buffer by removing leading 
  817  00008700 6100F9C6               BSR       TIDY                  ;leading and multiple embeded spaces 
  818  00008704 4E73                   RTE       
  819  00008706 0C01000F     TRAP15:   CMP.B     #15,D1                ;D1 = 15 = Execute the command in 
  820  0000870A 6606                   BNE.S     TRAP16                ;the line buffer 
  821  0000870C 6100F9FC               BSR       EXECUTE
  822  00008710 4E73                   RTE       
  823  00008712 0C010010     TRAP16:   CMP.B     #16,D1                ;D1 = 16 = Call RESTORE to transfer 
  824  00008716 6606                   BNE.S     TRAP17                ;the registers in TSK_T to the 68000 
  825  00008718 6100015A               BSR       RESTORE               ;and therefore execute a program 
  826  0000871C 4E73                   RTE       
  827  0000871E 4E73         TRAP17:   RTE       
  828                        * 
  829                        ************************************************************************* 
  830                        * 
  831                        *  Display exception frame (D0 - D7, A0 - A6, USP, SSP, SR, PC) 
  832                        *  EX_DIS prints registers saved after a breakpoint or exception 
  833                        *  The registers are saved in TSK_T 
  834                        * 
  835  00008720 4BEE0056     EX_DIS:   LEA.L     TSK_T(A6),A5          ;A5 points to display frame 
  836  00008724 49FA0313               LEA.L     MES3(PC),A4           ;Point to heading 
  837  00008728 6100F962               BSR       HEADING               ;and print it 
  838  0000872C 3C3C0007               MOVE.W    #7,D6                 ;8 pairs of registers to display 
  839  00008730 4205                   CLR.B     D5                    ;D5 is the line counter 
  840  00008732 1005         EX_D1:    MOVE.B    D5,D0                 ;Put current register number in D0 
  841  00008734 6100FABE               BSR       OUT1X                 ;and print it 
  842  00008738 6100FB54               BSR       PSPACE                ;and a space 
  843  0000873C 5205                   ADD.B     #1,D5                 ;Update counter for next pair 
  844  0000873E 2015                   MOVE.L    (A5),D0               ;Get data register to be displayed 
  845  00008740 6100FADC               BSR       OUT8X                 ;from the frame and print it 
  846  00008744 49FA0311               LEA.L     MES4(PC),A4           ;Print string of spaces 
  847  00008748 6100F932               BSR.L     PSTRING               ;between data and address registers 
  848  0000874C 202D0020               MOVE.L    32(A5),D0             ;Get address register to be displayed 
  849  00008750 6100FACC               BSR       OUT8X                 ;which is 32 bytes on from data reg 
  850  00008754 6100F916               BSR       NEWLINE
  851  00008758 4BED0004               LEA.L     4(A5),A5              ;Point to next pair (ie Di, Ai) 
  852  0000875C 51CEFFD4               DBRA      D6,EX_D1              ;Repeat until all displayed 
  853  00008760 4BED0020               LEA.L     32(A5),A5             ;Adjust pointer by 8 longwords 
  854  00008764 6100F906               BSR       NEWLINE               ;to point to SSP 
  855  00008768 49FA02C6               LEA.L     MES2A(PC),A4          ;Point to "SS =" 
  856  0000876C 6100F90E               BSR       PSTRING               ;Print it 
  857  00008770 201D                   MOVE.L    (A5)+,D0              ;Get SSP from frame 
  858  00008772 6100FAAA               BSR       OUT8X                 ;and display it 
  859  00008776 6100F8F4               BSR       NEWLINE
  860  0000877A 49FA02A2               LEA.L     MES1(PC),A4           ;Point to 'SR =' 
  861  0000877E 6100F8FC               BSR       PSTRING               ;Print it 
  862  00008782 301D                   MOVE.W    (A5)+,D0              ;Get status register 
  863  00008784 6100FA90               BSR       OUT4X                 ;Display status 
  864  00008788 6100F8E2               BSR       NEWLINE
  865  0000878C 49FA0299               LEA.L     MES2(PC),A4           ;Point to 'PC =' 
  866  00008790 6100F8EA               BSR       PSTRING               ;Print it 
  867  00008794 201D                   MOVE.L    (A5)+,D0              ;Get PC 
  868  00008796 6100FA86               BSR       OUT8X                 ;Display PC 
  869  0000879A 6000F8D0               BRA       NEWLINE               ;Newline and return 
  870                        * 
  871                        ************************************************************************* 
  872                        * 
  873                        *  Exception handling routines 
  874                        * 
  875           0000879E     IL_ER:    EQU       *                     ;Illegal instruction exception 
  876  0000879E 2F0C                   MOVE.L    A4,-(A7)              ;Save A4 
  877  000087A0 49FA02DF               LEA.L     MES10(PC),A4          ;Point to heading 
  878  000087A4 6100F8E6               BSR       HEADING               ;Print it 
  879  000087A8 285F                   MOVE.L    (A7)+,A4              ;Restore A4 
  880  000087AA 6176                   BSR.S     GROUP2                ;Save registers in display frame 
  881  000087AC 6100FF72               BSR       EX_DIS                ;Display registers saved in frame 
  882  000087B0 6000F88E               BRA       WARM                  ;Abort from illegal instruction 
  883                        * 
  884           000087B4     BUS_ER:   EQU       *                     ;Bus error (group 1) exception 
  885  000087B4 2F0C                   MOVE.L    A4,-(A7)              ;Save A4 
  886  000087B6 49FA02A9               LEA.L     MES8(PC),A4           ;Point to heading 
  887  000087BA 6100F8D0               BSR       HEADING               ;Print it 
  888  000087BE 285F                   MOVE.L    (A7)+,A4              ;Restore A4 
  889  000087C0 602C                   BRA.S     GROUP1                ;Deal with group 1 exception 
  890                        * 
  891           000087C2     ADD_ER:   EQU       *                     ;Address error (group 1) exception 
  892  000087C2 2F0C                   MOVE.L    A4,-(A7)              ;Save A4 
  893  000087C4 49FA02A9               LEA.L     MES9(PC),A4           ;Point to heading 
  894  000087C8 6100F8C2               BSR       HEADING               ;Print it 
  895  000087CC 285F                   MOVE.L    (A7)+,A4              ;Restore A4 
  896  000087CE 601E                   BRA.S     GROUP1                ;Deal with group 1 exception 
  897                        * 
  898           000087D0     BRKPT:    EQU       *                     ;Deal with breakpoint 
  899  000087D0 48E7FFFE               MOVEM.L   D0-D7/A0-A6,-(A7)     ;Save all registers 
  900  000087D4 61000180               BSR       BR_CLR                ;Clear breakpoints in code 
  901  000087D8 4CDF7FFF               MOVEM.L   (A7)+,D0-D7/A0-A6     ;Restore registers 
  902  000087DC 6144                   BSR.S     GROUP2                ;Treat as group 2 exception 
  903  000087DE 49FA02B7               LEA.L     MES11(PC),A4          ;Point to heading 
  904  000087E2 6100F8A8               BSR       HEADING               ;Print it 
  905  000087E6 6100FF38               BSR       EX_DIS                ;Display saved registers 
  906  000087EA 6000F854               BRA       WARM                  ;Return to monitor 
  907                        * 
  908                        *       GROUP1 is called by address and bus error exceptions 
  909                        *       These are "turned into group 2" exceptions (eg TRAP) 
  910                        *       by modifying the stack frame saved by a group 1 exception 
  911                        * 
  912  000087EE 48E78080     GROUP1:   MOVEM.L   D0/A0,-(A7)           ;Save working registers 
  913  000087F2 206F0012               MOVE.L    18(A7),A0             ;Get PC from group 1 stack frame 
  914  000087F6 302F000E               MOVE.W    14(A7),D0             ;Get instruction from stack frame 
  915  000087FA B060                   CMP.W     -(A0),D0              ;Now backtrack to find the "correct PC" 
  916  000087FC 670E                   BEQ.S     GROUP1A               ;by matching the op-code on the stack 
  917  000087FE B060                   CMP.W     -(A0),D0              ;with the code in the region of the 
  918  00008800 670A                   BEQ.S     GROUP1A               ;PC on the stack 
  919  00008802 B060                   CMP.W     -(A0),D0
  920  00008804 6706                   BEQ.S     GROUP1A
  921  00008806 B060                   CMP.W     -(A0),D0
  922  00008808 6702                   BEQ.S     GROUP1A
  923  0000880A 5588                   SUBQ.L    #2,A0
  924  0000880C 2F480012     GROUP1A:  MOVE.L    A0,18(A7)             ;Restore modified PC to stack frame 
  925  00008810 4CDF0101               MOVEM.L   (A7)+,D0/A0           ;Restore working registers 
  926  00008814 4FEF0008               LEA.L     8(A7),A7              ;Adjust stack pointer to group 1 type 
  927  00008818 6108                   BSR.S     GROUP2                ;Now treat as group 1 exception 
  928  0000881A 6100FF04               BSR       EX_DIS                ;Display contents of exception frame 
  929  0000881E 6000F820               BRA       WARM                  ;Exit to monitor - no RTE from group 2 
  930                        * 
  931           00008822     GROUP2:   EQU       *                     ;Deal with group 2 exceptions 
  932  00008822 48E7FFFF               MOVEM.L   A0-A7/D0-D7,-(A7)     ;Save all registers on the stack 
  933  00008826 303C000E               MOVE.W    #14,D0                ;Transfer D0 - D7, A0 - A6 from 
  934  0000882A 41EE0056               LEA.L     TSK_T(A6),A0          ;the stack to the display frame 
  935  0000882E 20DF         GROUP2A:  MOVE.L    (A7)+,(A0)+           ;Move a register from stack to frame 
  936  00008830 51C8FFFC               DBRA      D0,GROUP2A            ;and repeat until D0-D7/A0-A6 moved 
  937  00008834 4E6A                   MOVE.L    USP,A2                ;Get the user stack pointer and put it 
  938  00008836 20CA                   MOVE.L    A2,(A0)+              ;in the A7 position in the frame 
  939  00008838 201F                   MOVE.L    (A7)+,D0              ;Now transfer the SSP to the frame, 
  940  0000883A 04800000000A           SUB.L     #10,D0                ;remembering to account for the 
  941  00008840 20C0                   MOVE.L    D0,(A0)+              ;data pushed on the stack to this point 
  942  00008842 225F                   MOVE.L    (A7)+,A1              ;Copy TOS (return address) to A1 
  943  00008844 30DF                   MOVE.W    (A7)+,(A0)+           ;Move SR to display frame 
  944  00008846 201F                   MOVE.L    (A7)+,D0              ;Get PC in D0 
  945  00008848 5580                   SUBQ.L    #2,D0                 ;Move back to current instruction 
  946  0000884A 20C0                   MOVE.L    D0,(A0)+              ;Put adjusted PC in display frame 
  947  0000884C 4ED1                   JMP       (A1)                  ;Return from subroutine 
  948                        * 
  949                        ************************************************************************* 
  950                        * 
  951                        *  GO executes a program either from a supplied address or 
  952                        *  by using the data in the display frame 
  953  0000884E 6100F960     GO:       BSR       PARAM                 ;Get entry address (if any) 
  954  00008852 4A07                   TST.B     D7                    ;Test for error in input 
  955  00008854 6708                   BEQ.S     GO1                   ;If D7 zero then OK 
  956  00008856 49FA027F               LEA.L     ERMES1(PC),A4         ;Else point to error message, 
  957  0000885A 6000F820               BRA       PSTRING               ;print it and return 
  958  0000885E 4A80         GO1:      TST.L     D0                    ;If no address entered then get 
  959  00008860 670A                   BEQ.S     GO2                   ;address from display frame 
  960  00008862 2D40009C               MOVE.L    D0,TSK_T+70(A6)       ;Else save address in display frame 
  961  00008866 3D7C2700009A           MOVE.W    #$2700,TSK_T+68(A6)   ;Store dummy status in frame 
  962  0000886C 6006         GO2:      BRA.S     RESTORE               ;Restore volatile environment and go 
  963                        * 
  964  0000886E 6100007A     GB:       BSR       BR_SET                ;Same as go but presets breakpoints 
  965  00008872 60DA                   BRA.S     GO                    ;Execute program 
  966                        * 
  967                        *        RESTORE moves the volatile environment from the display 
  968                        *        frame and transfers it to the 68000's registers. This 
  969                        *        re-runs a program suspended after an exception 
  970                        * 
  971  00008874 47EE0056     RESTORE:  LEA.L     TSK_T(A6),A3          ;A3 points to display frame 
  972  00008878 47EB004A               LEA.L     74(A3),A3             ;A3 now points to end of frame + 4 
  973  0000887C 4FEF0004               LEA.L     4(A7),A7              ;Remove return address from stack 
  974  00008880 303C0024               MOVE.W    #36,D0                ;Counter for 37 words to be moved 
  975  00008884 3F23         REST1:    MOVE.W    -(A3),-(A7)           ;Move word from display frame to stack 
  976  00008886 51C8FFFC               DBRA      D0,REST1              ;Repeat until entire frame moved 
  977  0000888A 4CDF00FF               MOVEM.L   (A7)+,D0-D7           ;Restore old data registers from stack 
  978  0000888E 4CDF7F00               MOVEM.L   (A7)+,A0-A6           ;Restore old address registers 
  979  00008892 4FEF0008               LEA.L     8(A7),A7              ;Except SSP/USP - so adjust stack 
  980  00008896 4E73                   RTE                             ;Return from exception to run program 
  981                        * 
  982           00008898     TRACE:    EQU       *                     ;TRACE exception (rudimentary version) 
  983  00008898 287A020B               MOVE.L    MES12(PC),A4          ;Point to heading 
  984  0000889C 6100F7EE               BSR       HEADING               ;Print it 
  985  000088A0 6100FF4C               BSR       GROUP1                ;Save volatile environment 
  986  000088A4 6100FE7A               BSR       EX_DIS                ;Display it 
  987  000088A8 6000F796               BRA       WARM                  ;Return to monitor 
  988                        * 
  989                        ************************************************************************* 
  990                        *  Breakpoint routines: BR_GET gets the address of a breakpoint and 
  991                        *  puts it in the breakpoint table. It does not plant it in the code. 
  992                        *  BR_SET plants all breakpoints in the code. NOBR removes one or all 
  993                        *  breakpoints from the table. KILL removes breakpoints from the code. 
  994                        * 
  995  000088AC 6100F902     BR_GET:   BSR       PARAM                 ;Get breakpoint address in table 
  996  000088B0 4A07                   TST.B     D7                    ;Test for input error 
  997  000088B2 6708                   BEQ.S     BR_GET1               ;If no error then continue 
  998  000088B4 49FA0221               LEA.L     ERMES1(PC),A4         ;Else display error 
  999  000088B8 6000F7C2               BRA       PSTRING               ;and return 
 1000  000088BC 47EE00A0     BR_GET1:  LEA.L     BP_TAB(A6),A3         ;A6 points to breakpoint table 
 1001  000088C0 2A40                   MOVE.L    D0,A5                 ;Save new BP address in A5 
 1002  000088C2 2C00                   MOVE.L    D0,D6                 ;and in D6 because D0 gets corrupted 
 1003  000088C4 3A3C0007               MOVE.W    #7,D5                 ;Eight entries to test 
 1004  000088C8 201B         BR_GET2:  MOVE.L    (A3)+,D0              ;Read entry from breakpoint table 
 1005  000088CA 660C                   BNE.S     BR_GET3               ;If not zero display existing BP 
 1006  000088CC 4A86                   TST.L     D6                    ;Only store a non-zero breakpoint 
 1007  000088CE 6710                   BEQ.S     BR_GET4
 1008  000088D0 274DFFFC               MOVE.L    A5,-4(A3)             ;Store new breakpoint in table 
 1009  000088D4 3695                   MOVE.W    (A5),(A3)             ;Save code at BP address in table 
 1010  000088D6 4286                   CLR.L     D6                    ;Clear D6 to avoid repetition 
 1011  000088D8 6100F944     BR_GET3:  BSR       OUT8X                 ;Display this breakpoint 
 1012  000088DC 6100F78E               BSR       NEWLINE
 1013  000088E0 47EB0002     BR_GET4:  LEA.L     2(A3),A3              ;Step past stored op-code 
 1014  000088E4 51CDFFE2               DBRA      D5,BR_GET2            ;Repeat until all entries tested 
 1015  000088E8 4E75                   RTS                             ;Return 
 1016                        * 
 1017           000088EA     BR_SET:   EQU       *                     ;Plant any breakpoints in user code 
 1018  000088EA 41EE00A0               LEA.L     BP_TAB(A6),A0         ;A0 points to BP table 
 1019  000088EE 45EE009C               LEA.L     TSK_T+70(A6),A2       ;A2 points to PC in display frame 
 1020  000088F2 2452                   MOVE.L    (A2),A2               ;Now A2 contains value of PC 
 1021  000088F4 303C0007               MOVE.W    #7,D0                 ;Up to eight entries to plant 
 1022  000088F8 2218         BR_SET1:  MOVE.L    (A0)+,D1              ;Read breakpoint address from table 
 1023  000088FA 670A                   BEQ.S     BR_SET2               ;If zero then skip planting 
 1024  000088FC B28A                   CMP.L     A2,D1                 ;Don't want to plant BP at current PC 
 1025  000088FE 6706                   BEQ.S     BR_SET2               ;location, so skip planting if same 
 1026  00008900 2241                   MOVE.L    D1,A1                 ;Transfer BP address to address reg 
 1027  00008902 32BC4E4E               MOVE.W    #TRAP_14,(A1)         ;Plant op-code for TRAP #14 in code 
 1028  00008906 41E80002     BR_SET2:  LEA.L     2(A0),A0              ;Skip past op-code field in table 
 1029  0000890A 51C8FFEC               DBRA      D0,BR_SET1            ;Repeat until all entries tested 
 1030  0000890E 4E75                   RTS       
 1031                        * 
 1032           00008910     NOBR:     EQU       *                     ;Clear one or all breakpoints 
 1033  00008910 6100F89E               BSR       PARAM                 ;Get BP address (if any) 
 1034  00008914 4A07                   TST.B     D7                    ;Test for input error 
 1035  00008916 6708                   BEQ.S     NOBR1                 ;If no error then skip abort 
 1036  00008918 49FA01BD               LEA.L     ERMES1(PC),A4         ;Point to error message 
 1037  0000891C 6000F75E               BRA       PSTRING               ;Display it and return 
 1038  00008920 4A80         NOBR1:    TST.L     D0                    ;Test for null address (clear all) 
 1039  00008922 6720                   BEQ.S     NOBR4                 ;If no address then clear all entries 
 1040  00008924 2240                   MOVE.L    D0,A1                 ;Else just clear breakpoint in A1 
 1041  00008926 41EE00A0               LEA.L     BP_TAB(A6),A0         ;A0 points to BP table 
 1042  0000892A 303C0007               MOVE.W    #7,D0                 ;Up to eight entries to test 
 1043  0000892E 2218         NOBR2:    MOVE.L    (A0)+,D1              ;Get entry and 
 1044  00008930 41E80002               LEA.L     2(A0),A0              ;skip past op-code field 
 1045  00008934 B289                   CMP.L     A1,D1                 ;Is this the one? 
 1046  00008936 6706                   BEQ.S     NOBR3                 ;If so go and clear entry 
 1047  00008938 51C8FFF4               DBRA      D0,NOBR2              ;Repeat until all tested 
 1048  0000893C 4E75                   RTS       
 1049  0000893E 42A8FFFA     NOBR3:    CLR.L     -6(A0)                ;Clear address in BP table 
 1050  00008942 4E75                   RTS       
 1051  00008944 41EE00A0     NOBR4:    LEA.L     BP_TAB(A6),A0         ;Clear all 8 entries in BP table 
 1052  00008948 303C0007               MOVE.W    #7,D0                 ;Eight entries to clear 
 1053  0000894C 4298         NOBR5:    CLR.L     (A0)+                 ;Clear breakpoint address 
 1054  0000894E 4258                   CLR.W     (A0)+                 ;Clear op-code field 
 1055  00008950 51C8FFFA               DBRA      D0,NOBR5              ;Repeat until all done 
 1056  00008954 4E75                   RTS       
 1057                        * 
 1058           00008956     BR_CLR:   EQU       *                     ;Remove breakpoints from code 
 1059  00008956 41EE00A0               LEA.L     BP_TAB(A6),A0         ;A0 points to breakpoint table 
 1060  0000895A 303C0007               MOVE.W    #7,D0                 ;Up to eight entries to clear 
 1061  0000895E 2218         BR_CLR1:  MOVE.L    (A0)+,D1              ;Get address of BP in D1 
 1062  00008960 2241                   MOVE.L    D1,A1                 ;and put copy in A1 
 1063  00008962 4A81                   TST.L     D1                    ;Test this breakpoint 
 1064  00008964 6702                   BEQ.S     BR_CLR2               ;If zero then skip BP clearing 
 1065  00008966 3290                   MOVE.W    (A0),(A1)             ;Else restore op-code 
 1066  00008968 41E80002     BR_CLR2:  LEA.L     2(A0),A0              ;Skip past op-code field 
 1067  0000896C 51C8FFF0               DBRA      D0,BR_CLR1            ;Repeat until all tested 
 1068  00008970 4E75                   RTS       
 1069                        * 
 1070                        *  REG_MOD modifies a register in the display frame. The command 
 1071                        *  format is REG <reg> <value>. E.g. REG D3 1200 
 1072                        * 
 1073  00008972 4281         REG_MOD:  CLR.L     D1                    ;D1 to hold name of register 
 1074  00008974 41EE0040               LEA.L     BUFFPT(A6),A0         ;A0 contains address of buffer pointer 
 1075  00008978 2050                   MOVE.L    (A0),A0               ;A0 now points to next char in buffer 
 1076  0000897A 1218                   MOVE.B    (A0)+,D1              ;Put first char of name in D1 
 1077  0000897C E159                   ROL.W     #8,D1                 ;Move char one place left 
 1078  0000897E 1218                   MOVE.B    (A0)+,D1              ;Get second char in D1 
 1079  00008980 41E80001               LEA.L     1(A0),A0              ;Move pointer past space in buffer 
 1080  00008984 2D480040               MOVE.L    A0,BUFFPT(A6)         ;Update buffer pointer 
 1081  00008988 4282                   CLR.L     D2                    ;D2 is the character pair counter 
 1082  0000898A 41FA0122               LEA.L     REGNAME(PC),A0        ;A0 points to string of character pairs 
 1083  0000898E 43D0                   LEA.L     (A0),A1               ;A1 also points to string 
 1084  00008990 B258         REG_MD1:  CMP.W     (A0)+,D1              ;Compare a char pair with input 
 1085  00008992 6712                   BEQ.S     REG_MD2               ;If match then exit loop 
 1086  00008994 5282                   ADD.L     #1,D2                 ;Else increment match counter 
 1087  00008996 0C8200000013           CMP.L     #19,D2                ;Test for end of loop 
 1088  0000899C 66F2                   BNE       REG_MD1               ;Continue until all pairs matched 
 1089  0000899E 49FA0137               LEA.L     ERMES1(PC),A4         ;If here then error 
 1090  000089A2 6000F6D8               BRA       PSTRING               ;Display error and return 
 1091  000089A6 43EE0056     REG_MD2:  LEA.L     TSK_T(A6),A1          ;A1 points to display frame 
 1092  000089AA E582                   ASL.L     #2,D2                 ;Multiply offset by 4 (4 bytes/entry) 
 1093  000089AC 0C8200000048           CMP.L     #72,D2                ;Test for address of PC 
 1094  000089B2 6602                   BNE.S     REG_MD3               ;If not PC then all is OK 
 1095  000089B4 5582                   SUB.L     #2,D2                 ;else dec PC pointer as Sr is a word 
 1096  000089B6 45F12000     REG_MD3:  LEA.L     (A1,D2),A2            ;Calculate address of entry in disptable 
 1097  000089BA 2012                   MOVE.L    (A2),D0               ;Get old contents 
 1098  000089BC 6100F860               BSR       OUT8X                 ;Display them 
 1099  000089C0 6100F6AA               BSR       NEWLINE
 1100  000089C4 6100F7EA               BSR       PARAM                 ;Get new data 
 1101  000089C8 4A07                   TST.B     D7                    ;Test for input error 
 1102  000089CA 6708                   BEQ.S     REG_MD4               ;If no error then go and store data 
 1103  000089CC 49FA0109               LEA.L     ERMES1(PC),A4         ;Else point to error message 
 1104  000089D0 6000F6AA               BRA       PSTRING               ;print it and return 
 1105  000089D4 0C8200000044 REG_MD4:  CMP.L     #68,D2                ;If this address is the SR then 
 1106  000089DA 6704                   BEQ.S     REG_MD5               ;we have only a word to store 
 1107  000089DC 2480                   MOVE.L    D0,(A2)               ;Else store new data in display frame 
 1108  000089DE 4E75                   RTS       
 1109  000089E0 3480         REG_MD5:  MOVE.W    D0,(A2)               ;Store SR (one word) 
 1110  000089E2 4E75                   RTS       
 1111                        * 
 1112                        ************************************************************************* 
 1113                        * 
 1114           000089E4     X_UN:     EQU       *                     ;Uninitialized exception vector routine 
 1115  000089E4 49FA0157               LEA.L     ERMES6(PC),A4         ;Point to error message 
 1116  000089E8 6100F692               BSR       PSTRING               ;Display it 
 1117  000089EC 6100FD32               BSR       EX_DIS                ;Display registers 
 1118  000089F0 6000F64E               BRA       WARM                  ;Abort 
 1119                        * 
 1120                        ************************************************************************* 
 1121                        * 
 1122                        *  All strings and other fixed parameters here 
 1123                        * 
 1124  000089F4 545342554720 BANNER:   DC.B      'TSBUG 2 Version 23.07.86',0,0
                322056657273
                696F6E203233
                2E30372E3836
                0000        
 1125  00008A0E 0D0A3F00     CRLF:     DC.B      CR,LF,'?',0
 1126  00008A12 0D0A53310000 HEADER:   DC.B      CR,LF,'S','1',0,0
 1127  00008A18 533920200000 TAIL:     DC.B      'S9  ',0,0
 1128  00008A1E 20535220203D MES1:     DC.B      ' SR  =  ',0
                202000      
 1129  00008A27 20504320203D MES2:     DC.B      ' PC  =  ',0
                202000      
 1130  00008A30 20535320203D MES2A:    DC.B      ' SS  =  ',0
                202000      
 1131  00008A39 202044617461 MES3:     DC.B      '  Data reg       Address reg',0,0
                207265672020
                202020202041
                646472657373
                207265670000
 1132  00008A57 202020202020 MES4:     DC.B      '        ',0,0
                20200000    
 1133  00008A61 427573206572 MES8:     DC.B      'Bus error   ',0,0
                726F72202020
                0000        
 1134  00008A6F 416464726573 MES9:     DC.B      'Address error   ',0,0
                73206572726F
                722020200000
 1135  00008A81 496C6C656761 MES10:    DC.B      'Illegal instruction ',0,0
                6C20696E7374
                72756374696F
                6E200000    
 1136  00008A97 427265616B70 MES11:    DC.B      'Breakpoint  ',0,0
                6F696E742020
                0000        
 1137  00008AA5 547261636520 MES12:    DC.B      'Trace   ',0
                202000      
 1138  00008AAE 443044314432 REGNAME:  DC.B      'D0D1D2D3D4D5D6D7'
                443344344435
                44364437    
 1139  00008ABE 413041314132           DC.B      'A0A1A2A3A4A5A6A7'
                413341344135
                41364137    
 1140  00008ACE 53535352               DC.B      'SSSR'
 1141  00008AD2 5043202000             DC.B      'PC  ',0
 1142  00008AD7 4E6F6E2D7661 ERMES1:   DC.B      'Non-valid hexadecimal input  ',0
                6C6964206865
                786164656369
                6D616C20696E
                707574202000
 1143  00008AF5 496E76616C69 ERMES2:   DC.B      'Invalid command  ',0
                6420636F6D6D
                616E64202000
 1144  00008B07 4C6F6164696E ERMES3:   DC.B      'Loading error',0
                67206572726F
                7200        
 1145  00008B15 5461626C6520 ERMES4:   DC.B      'Table full  ',0,0
                66756C6C2020
                0000        
 1146  00008B23 427265616B70 ERMES5:   DC.B      'Breakpoint not active   ',0,0
                6F696E74206E
                6F7420616374
                697665202020
                0000        
 1147  00008B3D 556E696E6974 ERMES6:   DC.B      'Uninitialized exception ',0,0
                69616C697A65
                642065786365
                7074696F6E20
                0000        
 1148  00008B57 2052616E6765 ERMES7:   DC.B      ' Range error',0
                206572726F72
                00          
 1149                        * 
 1150                        *  COMTAB is the built-in command table. All entries are made up of 
 1151                        *         a string length + number of characters to match + the string 
 1152                        *         plus the address of the command relative to COMTAB 
 1153                        * 
 1154  00008B64 0404         COMTAB:   DC.B      4,4                   ;JUMP <address> causes execution to 
 1155  00008B66 4A554D50               DC.B      'JUMP'                ;begin at <address> 
 1156  00008B6A FFFFF6C2               DC.L      JUMP-COMTAB           ;n 
 1157  00008B6E 0803                   DC.B      8,3                   ;MEMORY <address> examines contents of 
 1158  00008B70 4D454D4F5259           DC.B      'MEMORY  '            ;<address> and allows them to be changed 
                2020        
 1159  00008B78 FFFFF6D8               DC.L      MEMORY-COMTAB
 1160  00008B7C 0402                   DC.B      4,2                   ;LOAD <string> loads S1/S2 records 
 1161  00008B7E 4C4F4144               DC.B      'LOAD'                ;from the host. <string> is sent to host 
 1162  00008B82 FFFFF738               DC.L      LOAD-COMTAB
 1163  00008B86 0402                   DC.B      4,2                   ;DUMP <string> sends S1 records to the 
 1164  00008B88 44554D50               DC.B      'DUMP'                ;host and is preceeded by <string>. 
 1165  00008B8C FFFFF80C               DC.L      DUMP-COMTAB
 1166  00008B90 0403                   DC.B      4,3                   ;TRAN enters the transparant mode 
 1167  00008B92 5452414E               DC.B      'TRAN'                ;and is exited by ESC,E. 
 1168  00008B96 FFFFF8C8               DC.L      TM-COMTAB
 1169  00008B9A 0402                   DC.B      4,2                   ;NOBR <address> removes the breakpoint 
 1170  00008B9C 4E4F4252               DC.B      'NOBR'                ;at <address> from the BP table. If 
 1171  00008BA0 FFFFFDAC               DC.L      NOBR-COMTAB           ;no address is given all BPs are removed. 
 1172  00008BA4 0402                   DC.B      4,2                   ;DISP displays the contents of the 
 1173  00008BA6 44495350               DC.B      'DISP'                ;pseudo registers in TSK_T. 
 1174  00008BAA FFFFFBBC               DC.L      EX_DIS-COMTAB
 1175  00008BAE 0402                   DC.B      4,2                   ;GO <address> starts program execution 
 1176  00008BB0 474F2020               DC.B      'GO  '                ;at <address> and loads regs from TSK_T 
 1177  00008BB4 FFFFFCEA               DC.L      GO-COMTAB
 1178  00008BB8 0402                   DC.B      4,2                   ;BRGT puts a breakpoint in the BP 
 1179  00008BBA 42524754               DC.B      'BRGT'                ;table - but not in the code 
 1180  00008BBE FFFFFD48               DC.L      BR_GET-COMTAB
 1181  00008BC2 0402                   DC.B      4,2                   ;PLAN puts the breakpoints in the code 
 1182  00008BC4 504C414E               DC.B      'PLAN'
 1183  00008BC8 FFFFFD86               DC.L      BR_SET-COMTAB
 1184  00008BCC 0404                   DC.B      4,4                   ;KILL removes breakpoints from the code 
 1185  00008BCE 4B494C4C               DC.B      'KILL'
 1186  00008BD2 FFFFFDF2               DC.L      BR_CLR-COMTAB
 1187  00008BD6 0402                   DC.B      4,2                   ;GB <address> sets breakpoints and 
 1188  00008BD8 47422020               DC.B      'GB  '                ;then calls GO. 
 1189  00008BDC FFFFFD0A               DC.L      GB-COMTAB
 1190  00008BE0 0403                   DC.B      4,3                   ;REG <reg> <value> loads <value> 
 1191  00008BE2 52454720               DC.B      'REG '                ;into <reg> in TASK_T. Used to preset 
 1192  00008BE6 FFFFFE0E               DC.L      REG_MOD-COMTAB        ;registers before a GO or GB 
 1193  00008BEA 0000                   DC.B      0,0
 1194                        * 
 1195                        ************************************************************************* 
 1196                        * 
 1197                        *  This is a list of the information needed to setup the DCBs 
 1198                        * 
 1199           00008BEC     DCB_LST:  EQU       *
 1200  00008BEC 434F4E5F494E DCB1:     DC.B      'CON_IN  '            ;Device name (8 bytes) 
                2020        
 1201  00008BF4 000084CA0001           DC.L      CON_IN,ACIA_1         ;Address of driver routine, device 
                0040        
 1202  00008BFC 0002                   DC.W      2                     ;Number of words in parameter field 
 1203  00008BFE 434F4E5F4F55 DCB2:     DC.B      'CON_OUT '
                5420        
 1204  00008C06 000084FA0001           DC.L      CON_OUT,ACIA_1
                0040        
 1205  00008C0E 0002                   DC.W      2
 1206  00008C10 4155585F494E DCB3:     DC.B      'AUX_IN  '
                2020        
 1207  00008C18 0000853A0001           DC.L      AUX_IN,ACIA_2
                0041        
 1208  00008C20 0002                   DC.W      2
 1209  00008C22 4155585F4F55 DCB4:     DC.B      'AUX_OUT '
                5420        
 1210  00008C2A 0000854C0001           DC.L      AUX_OUT,ACIA_2
                0041        
 1211  00008C32 0002                   DC.W      2
 1212  00008C34 425546465F49 DCB5:     DC.B      'BUFF_IN '
                4E20        
 1213  00008C3C 000085A00000           DC.L      BUFF_IN,BUFFER
                02D0        
 1214  00008C44 0002                   DC.W      2
 1215  00008C46 425546465F4F DCB6:     DC.B      'BUFF_OUT'
                5554        
 1216  00008C4E 000085AC0000           DC.L      BUFF_OT,BUFFER
                02D0        
 1217  00008C56 0002                   DC.W      2
 1218                        * 
 1219                        ************************************************************************* 
 1220                        * 
 1221                        *  DCB structure 
 1222                        * 
 1223                        *              ----------------------- 
 1224                        *       0 ->   | DCB  name           | 
 1225                        *              |---------------------| 
 1226                        *       8 ->   | Device driver       | 
 1227                        *              |---------------------| 
 1228                        *      12 ->   | Device address      | 
 1229                        *              |---------------------| 
 1230                        *      16 ->   |Size of param block  | 
 1231                        *              |---------------------| --- 
 1232                        *      18 ->   |      Status         |   | 
 1233                        *              | logical  | physical |   | S 
 1234                        *              |---------------------|   | 
 1235                        *              .                     .   . 
 1236                        *              |---------------------| --- 
 1237                        *    18+S ->   | Pointer to next DCB | 
 1238                        * 
 1239           00008000               END       $8000

Lines: 1239, Errors: 0, Warnings: 0.
